<?php

namespace TwitterApp\DefaultBundle\Repository;

use Doctrine\ORM\EntityRepository;
use TwitterApp\DefaultBundle\Entity\Tweet;
use Symfony\Component\Serializer\Serializer;
use Symfony\Component\Serializer\Encoder\XmlEncoder;
use Symfony\Component\Serializer\Encoder\JsonEncoder;
use Symfony\Component\Serializer\Normalizer\GetSetMethodNormalizer;

/**
 * TweetRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TweetRepository extends EntityRepository
{
	/*
	* getReleventInfo
	* 
	* Gets author handle, timestamp, and contents from the result array of our search request
	*/
	public function getReleventInfo($tweetStream) { 
			
		$encoders = array(new XmlEncoder(), new JsonEncoder());
		$normalizers = array(new GetSetMethodNormalizer());
		$serializer = new Serializer($normalizers, $encoders);

		//The twitter API returns our search results in JSON encoded format. We decode it into a more manageable array.
		$tweetStream = json_decode($tweetStream, true);

		$results = array(); 						 // 1) First we declare an array to hold our tweet objects...

		foreach ($tweetStream['statuses'] as $key) { // 2) then we iterate through our tweetStream array and grab the necessary info...
			//create a temporary Tweet object which we later push to our array
			$tmpTwt = new Tweet; 
			$tmpTwt->setHandle("@" . $key['user']['screen_name']);
			$tmpTwt->setDate(strtotime($key['created_at'])); //The Created At date is stored as UNIX timestamp
			$tmpTwt->setText($key['text']);

			array_push($results, $tmpTwt);
		}
		//serializes our array into JSON encoded
		$results = $serializer->serialize($results, "json"); 

		return $results; 							// 3) and finally return our results array back to the controller.
	}
}